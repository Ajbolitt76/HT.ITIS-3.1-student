# Домашняя работа №9

## DDD. Mapster

### Если вдруг проспал, на семинаре было
1. Что такое богатая и анемичная модели?
2. Богатая vs Анемичная модель. Плюсы и минусы.
3. Контексная валидация и инварианты. В чём отличия и когда используются?
4. Модель: aggregate + entity + value object.
5. Проблемы с aggregates.
6. Expressions в паттерне спецификация.
7. Bounded context: что это, как делить, как пересечь границу?

### Теория
1. [Расшифровка выступления Максима Аршинова на dotnext про богатые и анемичные модели](https://habr.com/ru/company/jugru/blog/503868/)
2. [Статья Максима Аршинова про реализацию паттерна спецификация на C#](https://habr.com/ru/articles/325280/)
3. [DDD на практике](https://habr.com/ru/articles/334126/)
4. [Банчмарк-тесты популярных мапперов в C#](https://www.youtube.com/watch?v=U8gSdQN2jWI&ab_channel=NickChapsas)
5. [Mapster](https://github.com/MapsterMapper/Mapster)
6. [Настройка и использование Mapster в ASP.NET Core приложении](https://www.youtube.com/watch?v=WzECbPsfYOI)

### Вопросы к семинару
1. Богатая модель - прямое нарушение принципов SOLID. Но почему некоторые разработчики тем не менее выбирают именно этот вариант реализации DDD?
2. В чём причины раскола лагеря программистов на сторонников богатой и анемичной модели?
3. Как вы понимаете, что такое инвариант модели?
4. Что такое aggregate в контексте разговора про модели?
5. Какие возникают проблемы с aggregates? Как их можно решить?
6. Что такое паттерн спецификация? Для чего он нужен? Где в нём используются Expressions и для чего?

### Практика:
1. Реализовать паттерн спецификация в DataAccess.Specs согласно статье Максима Аршинова из п.2 теории. Необходимо реализовать интерфейс IQueryableFilter, класс Specification, а также UsersSpecs согласно документации к каждому фильтру.
2. Подключить Mapster в проект Features и настроить автоматическую генерацию мапперов после сборки проекта с помощью Mapster.Tool. **Важное уточнение! Пока последняя стабильная версия Mapster по всей видимости [плохо работает с .net7](https://github.com/MapsterMapper/Mapster/issues/543#issuecomment-1447189969), поэтому рекомендуется устанавливать версию превью.**
3. В каждой фиче, где выделена логика Mapping, реализовать необходимые классы и интерфейсы: IMapper должен описывать сигнатуры методов маппинга, которые необходимо сгенерировать после сборки проекта, а в RegisterMappings необходимо создать конфиги для маппинга одной сущности в другую.
4. Реализовать метод AddMappers из MainProject.ServicesExtensions.Mapper: он с помощью рефлексии должен в переданной ему сборке найти все автосгенерированные мапперы и добавить их в DI.
5. Заменить все ручные маппинги в проекте на маппинги с использованием мапперов.