# Домашняя работа №7

## CQRS Validation

### Если вдруг проспал, на семинаре было
1) Для чего нужны декораторы?
2) Применяем декораторы для Railway-oriented programming в ООП языке.
3) Библиотека FluentValidation.

### Теория
1. [Паттерн декоратор](https://metanit.com/sharp/patterns/4.1.php).
2. [Документация](https://docs.fluentvalidation.net) по FluentValidation.
3. [О декораторах, сквозной функциональности, CQRS и слоеной архитектуре](https://habr.com/ru/articles/353258/)

### Практика
1. **Создать свой медиатор** в проекте **Dotnet.Homeworks.Mediator**, который реализует **IMediator** из того же проекта, и использовать его вместо MediatR в контроллерах. **Регистрировать медиатор через DependencyInjectionExtensions/ServiceCollectionExtensions**. Обратите внимание, что ваш медиатор должен корректно работать в режиме многопоточного исполнения программы.
2. Реализовать все классы (кроме папки Mapping) в папках **Users** и **UsersManagement** в проекте **Features**.
3. Подключить **FluentValidation** и написать валидацию для реквестов, где это необходимо. Валидаторы хранить вместе с фичами.
4. Реализовать PermissionCheck из Infrastructure/Validation/PermissionChecker, в котором метод CheckPermission будет проверять доступ к операции. Проверка проходит с помощью **IHttpContextAccessor**, проверяя Claims пользователя из HttpContext. Также необходимо регистрировать сервис через **Infrastructure/Validation/PermissionChecker/DependencyInjectionExtensions/ServiceCollectionExtensions**. Классы проверки, наподобие с валидаторами, хранить вместе с фичами.
5. Создать декораторы, которые будут проверять права доступа к операции, а также проводить валидацию данных только для фичи **Users**, которая представляет операции пользователя к своему аккаунту. Нужно проверять ClaimTypes.NameIdentifier. Построить цепочку из декораторов с помощью наследования, вызов которых начинается с **CqrsDecorator**. Реквесты фичи Users наследуют IClientRequest.
6. Создать свой PipelineBehavior в директории *Dotnet.Homeworks.Features/Behaviors*, наподобие такого же от MediatR, который будет делать то же самое, что и декоратор, но для операций **UserManagement**. Доступ к операциям этой фичи имеют только администраторы. Необходимо проверять ClaimTypes.Role. Для проверки использовать **enum Roles** в *Dotnet.Homeworks.Infrastructure/Validation/PermissionChecker/Enums*
7. Перенести вызов RegistrationService из контроллера в хэндлер создания пользователя.
8. Реализовать эндпоинты для UserManagementController.

### Неформальная рубрика "Что делать, если у меня лапки?":
* Логика работы медиатора: в момент подключения в DI медиатора один раз пробегаетесь по предоставленной вам сборке и ищете типы, реализующие нужные вам интерфейсы (IRequest, IRequestHandler). Подумайте: если ваш медиатор должен уметь по заданной команде находить нужный хэндлер, как это можно реализовать? Какую информацию вы можете сохранить на этом этапе? Не бойтесь использовать рефлексию везде, где она вам нужна. У вас нет каких-то серьёзных ограничений на производительность (разве что, пробегаться по всем типам из сборки на каждый запрос Send явно не стоит).
* Валидаторы FluentValidation должны фильтровать приходящие вам на вход данные. Например (и в тестах это проверяется), они должны валидировать почту, с которой пользователь пытается зарегистрироваться. Не забудьте их зарегистрировать в DI.
* В чём суть PermissionCheck? Это класс, который должен проверять наличие у пользователя необходимых разрешений на операцию. Заметили, что некоторые команды реализуют IClientRequest и IAdminRequest? Обычных пользователей нужно валидировать по NameIdentifier, а админов - по роли. Этот класс должен уметь в зависимости от пришедшей ему на вход команды валидировать запрос по нужному параметру. Т.е. условно если это Users/DeleteUserCommand, то проверять NameIdentifier, если же UserManagement/DeleteUserByAdminCommand - то валидировать по Role. Подумайте о масштабируемости решения. Может, делегировать всю непосредственную логику проверки разрешений для своих команд фичам, а в PermissionCheck работать только с абстракциями?
* Едем дальше. Вам требуется реализовать два подхода к валидации: через декораторы и через PipelineBehavior:
  * Остановимся на первом. Его нужно реализовать для фичи Users. Как уже было сказано, данный тип валидации представляет собой цепочку наследований декораторов. Начало цепочки - CqrsDecorator, от него вы наследуетесь во всех хэндлерах. Дальше смотрите сами, кого он будет вызывать. Напоминанием вам должен служить тот факт, что нужно провалидировать данные запроса с помощью валидаторов FluentValidation и проверить разрешения пользователя на запрашиваемую операцию (PermissionCheck).
  * Теперь о PipelineBehavior. Данный тип валидации хорош(или плох) тем, что всю логику вы отдаёте не откуп медиатору, а он сам разбирается с тем, как кого вызвать. Видите в проекте медиатора интерфейс IPipelineBehavior? Вашим валидаторам нужно его реализовать и как-то дать понять, в каком порядке из вызывать, а вся дальнейшая логика ложится на плечи вашего медиатора (то есть на ваши, так как вам нужно добавить эту логику в него).